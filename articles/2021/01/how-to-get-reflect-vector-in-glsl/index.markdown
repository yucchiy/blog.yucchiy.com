---
date: "2021-01-20T10:00:00+09:00"
draft: false
title: "GLSLのreflectとその計算方法"
tags: ["OpenGL", "Math", "GLSL"]

---

[こちら](https://learnopengl.com/Lighting/Basic-Lighting)をみながらOpenGLでBasic Lightまでやっていて、GLSLのふと[reflect](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/reflect.xhtml)について気になったのでメモしておきます。

## GLSLのreflectについて

GLSLの[reflect](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/reflect.xhtml)関数は、文字通り入力ベクトルに対して反射ベクトルを返す関数です。具体的には下記画像の _R_ を返却します。

![reflect関数の動作についての図示](./reflect-vector.png)

ここで、_I_ は 反射ベクトルを求めたい入力ベクトル、_N_ は反射面の方向を表す法線ベクトルです。 _N_ は正規化されている必要があります。
反射ベクトルなので_I_と_N_、_R_と_N_ が成す角は等しくなります。ちなみにドキュメントに書いてあるとおり、反射ベクトルの計算方法は _I_ - 2.0 * dot(_N_, _I_) * _N_となります。

## 反射ベクトルの導出

なぜ反射ベクトルが _I_ - 2.0 * dot(_N_, _I_) * _N_ となるのか導出してみます。

_R_を下図のように求めることを考えてみます。ただし導出の兼ね合いで入力ベクトル_I_は、一旦反転させたものを考えます。

![_R_の求め方](./reflect-step1.png)

反射なので_I_と_N_、_R_と_N_ が成す角は等しいです。そのため上図のように_I_から_N_に対して垂線を考えると、_I_とそのベクトル_h_を2倍したものを足し合わせるとちょうど_R_になります。

また、下図のように_I_から_N_の垂線の足が成すベクトル_n_を考えます。_n_を用いると、_R_は 2_n_ - _I_と書き直せます。

![_n_を用いた_R_の表現](./reflect-step2.png)

_n_は_I_を_N_に射影したベクトルで、一般に射影ベクトルと呼びます。_n_は、_N_と同じ方向を向いているため、_n_と_N_の長さがわかれば求まります。
さらに三角関数から、下図のように_n_の長さは_I_の長さを用いて表現できます。

![_n_を三角関数を用いて、_I_と、_I_と_N_の成す角で表現する](./reflect-step3.png)

θは_I_と_N_が成す角で、cosθは内積を用いて下記のように計算できます。

![_I_と_N_のなす角と内積](./reflect-cos.png)

上記と、_N_は正規化されているので単位ベクトルなため(つまり長さが1)、先程のベクトル_n_は下図のように書き表すことができます。

![_n_を_I_と_N_で表現する](./reflect-step4.png)

これでベクトル_n_を**既知の(というか入力値)値である**_I_と_N_で表すことができたので、最後に下図のように_R_を求めます。

![_R_の計算(途中)](./reflect-step5.png)

ただし最後に_I_は導出の都合で反転させていたので、下図のようにもう一度反転させます。_I_はそのまま符号を入れ替えます。2 * dot(_I_,_N_) * _N_の方は内積の計算の片方が逆を向くので、こちらもdot(_I_,_N_)の符号が入れ替わります。
よって、_R_は_I_ - 2.0 * dot(_N_, _I_) * _N_であることを示すことができました。

![_R_の計算(最終)](./reflect-step6.png)

## まとめ

GLSLのreflect関数について調べ、またその導出を行いました。
