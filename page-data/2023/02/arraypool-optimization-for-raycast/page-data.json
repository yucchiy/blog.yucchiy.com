{"componentChunkName":"component---src-templates-post-tsx","path":"/2023/02/arraypool-optimization-for-raycast/","result":{"data":{"markdownRemark":{"html":"<p>UnityのPhysicsが提供するレイキャストは、大まかに分けて当たった1点を返す<code>Physics.Raycast</code>と、指定したレイに当たったコリジョンをすべて返す<code>Physics.RaycastAll</code>の2つがあります。</p>\n<p>複数の結果を返す、という観点では、<code>Physics.RaycastAll</code>と<code>Physics.RaycastNonAlloc</code>というAPIが利用できます。</p>\n<p><code>Physics.RaycastAll</code>はクエリの結果をすべて返却します。結果は<code>RaycastHit[]</code>を返しますが、この配列は呼び出し時に<strong>都度確保</strong>されます。</p>\n<p><code>Physics.RaycastNonAlloc</code>はすでに確保された<code>RaycastHit[]</code>に対して結果の書き込みを行うことで、<code>GC.Alloc</code>を回避します。\n結果を格納する配列を、レイキャストを利用するコンポーネントやクラスの初期化時に確保しておくなどしておくと、レイキャスト呼び出し時は<code>GC.Alloc</code>を一切発生させないことができます。</p>\n<p>そのため、レイキャストの結果を複数取得したい場合、パフォーマンスを考慮すると大抵の場合は<code>Physics.RaycastNonAlloc</code>を使うことになります。</p>\n<p>ただし、この配列をレイキャストを行うコンポーネントやクラスのフィールドとして確保すると、複数コンポーネント間で重複した配列を確保することになり、地味ではありますがメモリ確保の効率が悪いです。\nまた、Unity標準ではArrayPoolの実装がないため、プロジェクトで独自の実装が必要になります。\n（ちなみにVisual ScriptingパッケージやGraphicsパッケージにはArrayPool実装がそれぞれ用意されていますが、あくまでもパッケージ側のクラスなので、それらはノーカウント。）</p>\n<p>.NET Standard 2.1には<code>ArrayPool&#x3C;T></code>が用意されているので、今回はこれを用いて<code>Physics.RaycastNonAlloc</code>に渡す配列を事前確保＆再利用する方法について紹介します。</p>\n<h2 id=\"arraypooltについて\" style=\"position:relative;\"><a href=\"#arraypoolt%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\" aria-label=\"arraypooltについて permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>ArrayPool&#x3C;T></code>について</h2>\n<p>.NET Standard 2.1で実装された配列のプール実装です。</p>\n<p><a href=\"https://learn.microsoft.com/ja-jp/dotnet/api/system.buffers.arraypool-1?view=net-5.0\">ArrayPool<T> クラス (System.Buffers) | Microsoft Learn</a></p>\n<p>.NET Standard 2.1はUnity2021.2から利用可能なので、2021 LTS以降で標準的に利用できるAPIになります。 利用方法を下記に示します。</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> aryLength <span class=\"token operator\">=</span> <span class=\"token number\">16</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 配列をプールから借りてくる</span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> rentAry <span class=\"token operator\">=</span> ArrayPool<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">.</span>Shared<span class=\"token punctuation\">.</span><span class=\"token function\">Rent</span><span class=\"token punctuation\">(</span>aryLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// なにか配列に対して処理</span>\n<span class=\"token comment\">// 試しに配列に対して適当な値をつっこんで</span>\n<span class=\"token comment\">// その合計を取る</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> aryLength<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    rentAry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> aryLength<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    sum <span class=\"token operator\">+=</span> rentAry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nDebug<span class=\"token punctuation\">.</span><span class=\"token function\">Log</span><span class=\"token punctuation\">(</span><span class=\"token interpolation-string\"><span class=\"token string\">$\"sum = </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span><span class=\"token expression language-csharp\">sum</span><span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 借りた配列を返却する</span>\nArrayPool<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">.</span>Shared<span class=\"token punctuation\">.</span><span class=\"token function\">Return</span><span class=\"token punctuation\">(</span>rentAry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>使い方はとてもシンプルで、<code>ArrayPool&#x3C;T>.Shared.Rent(length)</code>でプールから配列を借りてきて、使い終わったら<code>ArrayPool&#x3C;T>.Shared.Return(array)</code>で返却します。</p>\n<p><code>ArrayPool&#x3C;T></code>について、さらに詳細について知りたい方は<a href=\"https://ikorin2.hatenablog.jp/entry/2020/07/25/113904\">(C#) ArrayPool<T>.Shared 解体新書 - ネコのために鐘は鳴る</a>などが参考になります。</p>\n<h2 id=\"arraypooltとphysicsraycastnonallocを組み合わせる\" style=\"position:relative;\"><a href=\"#arraypoolt%E3%81%A8physicsraycastnonalloc%E3%82%92%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E3%82%8B\" aria-label=\"arraypooltとphysicsraycastnonallocを組み合わせる permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>ArrayPool&#x3C;T></code>と<code>Physics.RaycastNonAlloc</code>を組み合わせる</h2>\n<p><code>ArrayPool&#x3C;T></code>を利用して事前確保された配列プールを利用できることがわかったので、<code>Physics.RaycastNonAlloc</code>と組み合わせてみます。下記のように画面をクリックすると、クリック情報に対応するレイを生成して、そのレイに当たったオブジェクトをすべて非表示にするような実装を考えます。</p>\n<p><img src=\"/ec0963a818d185b311f4e8ed8c851a5c/sample.gif\" alt=\"画面をクリックしたら、レイが当たったオブジェクトを削除するやつ\"></p>\n<p>対象となるオブジェクトは下記のようにランダムに配置するものとします。</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token comment\">// 配置するオブジェクト数は_collisionCountで定義</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> _collisionCount<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// スフィアコリジョンが格納されたプレハブをターゲットする</span>\n    <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> sphereObject <span class=\"token operator\">=</span> <span class=\"token function\">Instantiate</span><span class=\"token punctuation\">(</span>_collisionPrefab<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    sphereObject<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token interpolation-string\"><span class=\"token string\">$\"sphere-</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span><span class=\"token expression language-csharp\">i</span><span class=\"token format-string\"><span class=\"token punctuation\">:</span>D4</span><span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">;</span>\n    sphereObject<span class=\"token punctuation\">.</span>transform<span class=\"token punctuation\">.</span><span class=\"token function\">SetParent</span><span class=\"token punctuation\">(</span>_root<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 半径をランダムに設定</span>\n    <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> radius <span class=\"token operator\">=</span> Random<span class=\"token punctuation\">.</span><span class=\"token function\">Range</span><span class=\"token punctuation\">(</span>_minRadius<span class=\"token punctuation\">,</span> _maxRadius<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    sphereObject<span class=\"token punctuation\">.</span>transform<span class=\"token punctuation\">.</span>localScale <span class=\"token operator\">=</span> Vector3<span class=\"token punctuation\">.</span>one <span class=\"token operator\">*</span> radius <span class=\"token operator\">*</span> <span class=\"token number\">2f</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 位置をランダムに設定</span>\n    <span class=\"token comment\">// _leftBottomおよび_rightTopはVector3で、</span>\n    <span class=\"token comment\">// 配置する領域の左下と右上を定義し、その２点の示す直方体内にスフィアを配置する</span>\n    sphereObject<span class=\"token punctuation\">.</span>transform<span class=\"token punctuation\">.</span>localPosition <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Vector3</span><span class=\"token punctuation\">(</span>\n        Random<span class=\"token punctuation\">.</span><span class=\"token function\">Range</span><span class=\"token punctuation\">(</span>_leftBottom<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> _rightTop<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        Random<span class=\"token punctuation\">.</span><span class=\"token function\">Range</span><span class=\"token punctuation\">(</span>_leftBottom<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">,</span> _rightTop<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        Random<span class=\"token punctuation\">.</span><span class=\"token function\">Range</span><span class=\"token punctuation\">(</span>_leftBottom<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">,</span> _rightTop<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上記のコリジョンに対して、<code>ArrayPool&#x3C;T></code>と<code>Physics.RaycastNonAlloc</code>を組み合わせて下記のように<code>GC.Alloc</code>なしのレイキャストを実現します。</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token comment\">// レイキャストの最大数を定義。仕様で決める。</span>\n<span class=\"token keyword\">const</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> MaxHitCount <span class=\"token operator\">=</span> <span class=\"token number\">128</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// クリックした画面座標とカメラの情報を元に、レイキャストで使うレイを生成する</span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> ray <span class=\"token operator\">=</span> <span class=\"token function\">GetClickRay</span><span class=\"token punctuation\">(</span>_camera<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// プールから配列を借りてくる</span>\n<span class=\"token comment\">// </span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> hits <span class=\"token operator\">=</span> ArrayPool<span class=\"token operator\">&lt;</span>RaycastHit<span class=\"token operator\">></span><span class=\"token punctuation\">.</span>Shared<span class=\"token punctuation\">.</span><span class=\"token function\">Rent</span><span class=\"token punctuation\">(</span>MaxHitCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// プールから借りてきた配列に結果を書き込む</span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> count <span class=\"token operator\">=</span> Physics<span class=\"token punctuation\">.</span><span class=\"token function\">RaycastNonAlloc</span><span class=\"token punctuation\">(</span>ray<span class=\"token punctuation\">,</span> hits<span class=\"token punctuation\">,</span> _camera<span class=\"token punctuation\">.</span>farClipPlane<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> count<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> hit <span class=\"token operator\">=</span> hits<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// hitを元になにか処理する</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hit<span class=\"token punctuation\">.</span>transform<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">TryGetComponent</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>MeshRenderer<span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 今回はとりあえず描画をオフにする実装</span>\n            <span class=\"token comment\">// 本当は、以後レイキャストの対象から外すなどするとよい</span>\n            meshRenderer<span class=\"token punctuation\">.</span>enabled <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 事前にInstanceIdから対応するMeshRendererの一覧を割り当てて</span>\n        <span class=\"token comment\">// hit.colliderInstanceIDを用いて、MeshRendererを引いたほうが速いかも？</span>\n        <span class=\"token comment\">// (未検証)</span>\n        <span class=\"token comment\">// if (_meshRenderers.TryGetValue(hit.colliderInstanceID, out var meshRenderer))</span>\n        <span class=\"token comment\">// {</span>\n        <span class=\"token comment\">//     meshRenderer.enabled = false;</span>\n        <span class=\"token comment\">// }</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 最後に配列をプールに戻す</span>\nArrayPool<span class=\"token operator\">&lt;</span>RaycastHit<span class=\"token operator\">></span><span class=\"token punctuation\">.</span>Shared<span class=\"token punctuation\">.</span><span class=\"token function\">Return</span><span class=\"token punctuation\">(</span>hits<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>ArrayPool&#x3C;T></code>の使い方は先述の利用方法と大きく変わりませんが、<code>RaycastHit</code>が<code>Collider</code>の参照を保持するので、参照をクリアするために返却の際に<code>Return</code>の第2引数に<code>true</code>を指定しています。<code>true</code>を指定することで、返却時にゼロクリアを実施します。</p>\n<p>また、配列を列挙する際に（配列の要素数ではなく）必ず<code>Physics.RaycastNonAlloc</code>の戻り値を最大数としてループを回します。この戻り値は実際にレイキャストで当たったコリジョン数を返し、その個数分配列の先頭要素から結果を書き込みます。\nそれ以外は無効な値になるので、これを利用しないために戻り値の個数でループを回します。</p>\n<p>さらにいうと<code>Rent</code>で実際に返ってくる配列の要素数は、必ず指定した要素数と同数返ってくる保証がない（2のべき乗の要素が確保される）といった<code>ArrayPool&#x3C;T></code>側の実装の都合があります。（が、これは<code>Physics.RaycastNonAlloc</code>の戻り値でループを回していれば問題にならないため今回は詳細を割愛します。）</p>\n<h2 id=\"まとめ\" style=\"position:relative;\"><a href=\"#%E3%81%BE%E3%81%A8%E3%82%81\" aria-label=\"まとめ permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>まとめ</h2>\n<p><code>ArrayPool&#x3C;T></code>と<code>Physics.RaycastNonAlloc</code>を用いて、複数個の結果を取るレイキャストを<code>GC.Alloc</code>なしで実行する方法について紹介しました。</p>\n<p>.NET Standard 2.1から利用できるAPIは、Unityでも効率的・効果的に利用できるケースが多そうなので、いろいろ試してみたいなと思います。</p>","excerpt":"UnityのPhysicsが提供するレイキャストは、大まかに分けて当たった1点を返すPhysics.Raycastと、指定したレイに当たったコリジョンをすべて返すPhysics.RaycastAllの2つがあります。 複数の結果を返す、という観点では、Physics.RaycastAllとPhysics.RaycastNonAllocというAPIが利用できます。 Physics.RaycastAllはクエリの結果をすべて返却します。結果はRaycastHit…","fields":{"slug":"/2023/02/arraypool-optimization-for-raycast/"},"frontmatter":{"date":"February 06, 2023","type":"tech","tags":["Unity",".NET Standard 2.1","Physics","最適化"],"title":".NET Standard 2.1のArrayPool<T>を用いたレイキャスト（Physics.RaycastNonAlloc）の最適化","description":".NET Standard 2.1のArrayPool<T>を用いてPhysics.RaycastNonAllocに渡す配列を事前確保＆再利用する方法について紹介します。","eyecatch":null}}},"pageContext":{"id":"135d6c57-909f-52d7-b237-07f201eab5a6"}},"staticQueryHashes":["1480509143","3159585216"]}