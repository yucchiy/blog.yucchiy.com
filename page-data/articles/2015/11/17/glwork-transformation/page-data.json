{"componentChunkName":"component---src-templates-post-tsx","path":"/articles/2015/11/17/glwork-transformation/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"http://blog.yucchiy.com/2015/11/10/hello-opengl-with-golang/\">前回</a>に引き続き, OpenGLをGolangで触ってワイワイやってる. 今回は, <a href=\"http://www.wakayama-u.ac.jp/~tokoi/lecture/gg/ggnote03.pdf\">このへん(PDF)</a>を題材に, 同次座標系とか変換の合成から, 平行移動や回転を表現する行列を学び, あとは投影変換やらビュー変換がどういう仕組みなのかを勉強（というか大学の頃の復習）して, 実際にコーディングするなどした.</p>\n<p>コーディングの様子がこちら. なんかVJ素材っぽい.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/78091852687db143153cbb806c327881/92bb4/glwork-transformation.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABRUlEQVQ4y6WTT07CQBSHf7/+ceOCuDDBxNjS29jEE7jyBhpqwoJLsPAAbmQhLlA6IFdRduAdBNsxQ4dhipjYOsmXafvmfe/1NUW30/Nf7++uxPNTR4hJW6QisRmLcdJ/6CeDx0EyEZNkNy5S0RZi3B0Ohxfz+QJoNI6OW2enH1GrJaMo2ksQBDIMw1/jijAIp/F5DLWaAN4ASABLAF8V+dS5L9CrSXJGUpLMSOYG4CfrGHLr3ErnjjzPMx3OdJVM7xKghOtLuF4Zzy+em3NY6T01He4VOm6RSG5RQhWjU0OoksqJ2/tNgcpC1aUtdP4jhPWK9hjqd0gJ78CaodXxehx1OiwJNZuPhb8LcwOdHI5b7GQBmJfObIUjW/huVcsqstz9U04ALErDr8d0IzwEcAkgAXAN4KYiKucWQEyyMJoLgDUxjm+2vSdCiwsboAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"gl-transformation\"\n        title=\"gl-transformation\"\n        src=\"/static/78091852687db143153cbb806c327881/5a190/glwork-transformation.png\"\n        srcset=\"/static/78091852687db143153cbb806c327881/772e8/glwork-transformation.png 200w,\n/static/78091852687db143153cbb806c327881/e17e5/glwork-transformation.png 400w,\n/static/78091852687db143153cbb806c327881/5a190/glwork-transformation.png 800w,\n/static/78091852687db143153cbb806c327881/c1b63/glwork-transformation.png 1200w,\n/static/78091852687db143153cbb806c327881/29007/glwork-transformation.png 1600w,\n/static/78091852687db143153cbb806c327881/92bb4/glwork-transformation.png 1824w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>gl-transformation</p></figcaption>\n  </figure></p>\n<p>前回からの変更点としては, モデルの変換行列・カメラの視点変換行列・投影行列をバーテックスシェーダに転送して, それぞれの頂点を変換しただけ.</p>\n<h2 id=\"実装\" style=\"position:relative;\"><a href=\"#%E5%AE%9F%E8%A3%85\" aria-label=\"実装 permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>実装</h2>\n<p>まずシェーダー.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#version 330\n\nuniform mat4 projection;\nuniform mat4 camera;\nuniform mat4 model;\n\nin vec3 vert;\n\nvoid main() {\n\tgl_Position = projection * camera * model * vec4(vert, 1);\n}</code></pre></div>\n<p>得に難しいことはしていない. 次にプログラム.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">projection := mgl32.Perspective(mgl32.DegToRad(45.0), float32(windowWidth)/windowHeight, 0.1, 10.0)\nprojectionUniform := gl.GetUniformLocation(program, gl.Str(\"projection\\x00\"))\ngl.UniformMatrix4fv(projectionUniform, 1, false, &amp;projection[0])\n\ncamera := mgl32.LookAtV(\n\tmgl32.Vec3{3, 3, 3},\n\tmgl32.Vec3{0, 0, 0},\n\tmgl32.Vec3{0, 1, 0},\n)\ncameraUniform := gl.GetUniformLocation(program, gl.Str(\"camera\\x00\"))\ngl.UniformMatrix4fv(cameraUniform, 1, false, &amp;camera[0])\n\nmodel := mgl32.Ident4()\nmodelUniform := gl.GetUniformLocation(program, gl.Str(\"model\\x00\"))\ngl.UniformMatrix4fv(modelUniform, 1, false, &amp;model[0])</code></pre></div>\n<p>本来は行列の計算も全部自分でやると良いが, 世の中には<a href=\"https://github.com/go-gl/mathgl\">mathgl</a>という,\n変換とかで利用しそうな関数とかデータ構造を一式用意してくれている便利なライブラリがあるので,\nとりあえず利用してる関数の中の計算と, 手計算があってればそのまま利用するなどした.</p>\n<p>あとはモデルの変換行列だけ, 時間が経過するごとにぐるぐる回るようにした.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">time := glfw.GetTime()\nelapsed := time - previousTime\npreviousTime = time\n\nangleX += math.Sin((elapsed / period) * math.Pi * 2.0)\nangleY += math.Sin((elapsed / period) / 6.0 * math.Pi * 2.0)\nangleZ += math.Sin((elapsed / period) / 3.0 * math.Pi * 2.0)\nmodel = mgl32.HomogRotate3DY(float32(angleY)).Mul4(mgl32.HomogRotate3DX(float32(angleX))).Mul4(mgl32.HomogRotate3DZ(float32(angleZ)))</code></pre></div>\n<p><code>period</code>秒の周期で, x軸に1回転, y軸に1/6回転, z軸に1/3回転するように実装している.</p>\n<p>ここで, <code>glfw.GetTime()</code>は, glfwの管理しているタイマーから, 経過時間を秒単位で取得する関数.</p>\n<p>成果物は<a href=\"https://github.com/yucchiy/toybox-opengl/blob/master/transform/main.go\">https://github.com/yucchiy/toybox-opengl/blob/master/transform/main.go</a>.</p>\n<h2 id=\"今後の予定\" style=\"position:relative;\"><a href=\"#%E4%BB%8A%E5%BE%8C%E3%81%AE%E4%BA%88%E5%AE%9A\" aria-label=\"今後の予定 permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>今後の予定</h2>\n<p>簡単な変換とかなら一通りかけるようになった. 引き続き<a href=\"http://www.wakayama-u.ac.jp/~tokoi/lecture/gg/\">この辺</a>を読みながら,\nシェーダーについて何ができるのか一通り把握するために勉強したい.</p>","excerpt":"前回に引き続き, OpenGLをGolangで触ってワイワイやってる. 今回は, このへん(PDF)を題材に, 同次座標系とか変換の合成から, 平行移動や回転を表現する行列を学び, あとは投影変換やらビュー変換がどういう仕組みなのかを勉強（というか大学の頃の復習）して, 実際にコーディングするなどした. コーディングの様子がこちら. なんかVJ…","fields":{"slug":"/articles/2015/11/17/glwork-transformation/"},"frontmatter":{"date":"November 17, 2015","type":null,"tags":["OpenGL","CG","Golang"],"title":"GolangでOpenGLで工作 - 変換","description":"前回に引き続いて、OpenGLをGolangで触ってる. 今回はモデルやらを変換して描画する感じのことをやった.","eyecatch":null}}},"pageContext":{"id":"53ebb857-88b9-5ae6-bca5-e7b9a7774c2c"}},"staticQueryHashes":["1480509143","3159585216"]}